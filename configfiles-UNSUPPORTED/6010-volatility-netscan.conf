# Logstash configuration for Volatility windows.netscan output
# This parser handles JSON format from Volatility3 windows.netscan plugin
# Scans for network connections including TCP, UDP, IPv4, and IPv6
#
# Usage: Place JSON files in the input directory configured below
# Index Pattern: volatility-netscan-*

filter {
  # Only process if this is a netscan document
  if [type] == "volatility-netscan" or "volatility-netscan" in [tags] {

    # Parse JSON if it's a string
    if [message] {
      json {
        source => "message"
        target => "network"
      }
    }

    # Extract network connection information
    mutate {
      add_field => {
        "process_id" => "%{[network][PID]}"
        "process_name" => "%{[network][Owner]}"
        "network_protocol" => "%{[network][Proto]}"
        "local_address" => "%{[network][LocalAddr]}"
        "local_port" => "%{[network][LocalPort]}"
        "foreign_address" => "%{[network][ForeignAddr]}"
        "foreign_port" => "%{[network][ForeignPort]}"
        "connection_state" => "%{[network][State]}"
        "network_offset" => "%{[network][Offset]}"
      }
      add_tag => [ "volatility", "memory_forensics", "network_analysis", "netscan" ]
    }

    # Parse connection creation timestamp
    if [network][Created] {
      date {
        match => [ "[network][Created]", "ISO8601", "yyyy-MM-dd'T'HH:mm:ssZ", "yyyy-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
        target => "connection_created_time"
      }
    }

    # Convert numeric fields
    mutate {
      convert => {
        "process_id" => "integer"
        "local_port" => "integer"
        "foreign_port" => "integer"
      }
    }

    # Determine IP version
    if [network_protocol] =~ /v6$/ {
      mutate {
        add_field => { "ip_version" => "IPv6" }
      }
    } else {
      mutate {
        add_field => { "ip_version" => "IPv4" }
      }
    }

    # Classify connection type
    if [network_protocol] =~ /^TCP/ {
      mutate {
        add_field => { "transport_protocol" => "TCP" }
      }
    } else if [network_protocol] =~ /^UDP/ {
      mutate {
        add_field => { "transport_protocol" => "UDP" }
      }
    }

    # Classify local vs remote connections
    if [local_address] == "0.0.0.0" or [local_address] == "::" {
      mutate {
        add_field => { "connection_type" => "listening" }
      }
    } else if [foreign_address] and [foreign_address] != "0.0.0.0" and [foreign_address] != "::" and [foreign_address] != "*" {
      mutate {
        add_field => { "connection_type" => "established" }
      }

      # Check if foreign address is external (not RFC1918/loopback)
      if [foreign_address] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.|::1|fe80:)/ {
        mutate {
          add_field => { "connection_scope" => "external" }
          add_tag => [ "external_connection" ]
        }
      } else {
        mutate {
          add_field => { "connection_scope" => "internal" }
        }
      }
    }

    # Flag suspicious ports
    if [local_port] {
      # Common malware/backdoor ports
      if [local_port] == 4444 or [local_port] == 31337 or [local_port] == 1337 or [local_port] == 6667 or [local_port] == 6666 {
        mutate {
          add_tag => [ "suspicious_port" ]
        }
      }
      # High ports (ephemeral range, but sometimes used for persistence)
      if [local_port] > 49152 {
        mutate {
          add_tag => [ "high_port" ]
        }
      }
    }

    if [foreign_port] {
      # Outbound to common C2 ports
      if [foreign_port] == 4444 or [foreign_port] == 8080 or [foreign_port] == 443 or [foreign_port] == 80 {
        mutate {
          add_field => { "foreign_port_classification" => "common_c2" }
        }
      }
    }

    # Add metadata fields
    mutate {
      add_field => {
        "volatility_plugin" => "windows.netscan"
        "analysis_type" => "network_connections"
      }
    }

    # GeoIP enrichment for foreign addresses (if GeoIP database available)
    if [foreign_address] and [connection_scope] == "external" {
      geoip {
        source => "foreign_address"
        target => "foreign_geo"
        fields => ["city_name", "country_name", "country_code2", "location", "continent_code"]
        tag_on_failure => ["_geoip_lookup_failure"]
      }
    }

    # Clean up
    mutate {
      remove_field => [ "message" ]
    }
  }
}

output {
  if [type] == "volatility-netscan" or "volatility-netscan" in [tags] {
    elasticsearch {
      hosts => ["localhost:9200"]
      index => "volatility-netscan-%{+YYYY.MM.dd}"
      document_type => "_doc"
    }
  }
}
