# SOF-ELKÂ® Configuration File
# (C)2023 Lewes Technology Consulting, LLC
#
# This file parses JSON-formatted Azure logs

filter {
  if [type] == "azure" {

    if [raw][System][Provider][Name] == "Microsoft-Windows-Security-Auditing" {
      #### Azure VM Event Logs, in XML format
      date {
        match => [ "[raw][System][TimeCreated][SystemTime]", "ISO8601" ]
      }

      mutate {
        rename => {
          "[raw][System][Provider][Name]" => "provider_name"
          "[raw][System][EventID][content]" => "event_id"
          "[raw][System][EventRecordID][content]" => "event_record_id"
          "[raw][System][Correlation][ActivityID]" => "correlation_guid"
          "[raw][System][Execution][ProcessID]" => "process_id"
          "[raw][System][Channel][content]" => "channel"
          "[raw][System][Channel][computer]" => "hostname"
        }
        gsub => [
          "correlation_guid", "[{}]", ""
        ]
        convert => {
          "event_id" => "integer"
          "event_record_id" => "integer"
          "process_id" => "integer"
        }
        add_tag => [ "azure_xml_vm_event_log" ]
      }

      if [raw][EventData][Data] {
        # convert the original "<Data Name='TargetUserName'>ADMINISTRATOR</Data>" format to
        # "TargetUserName: ADMINISTRATOR" format while reparenting into [event_data]
        ruby {
          path => "/usr/local/sof-elk/supporting-scripts/split_kv_to_fields.rb"
          script_params => {
            "source_field" => "[raw][EventData][Data]"
            "destination_field" => "[event_data]"
            "key_field" => "Name"
            "val_field" => "content"
          }
        }
      }
    }

    # there may be an array of target resources here - if so, put each resource into its own entry
    if [raw][properties][targetResources] {
      split {
        field => "[raw][properties][targetResources]"
      }
    }

    ### Azure SignIn Logs, in JSON format
    # https://docs.microsoft.com/en-us/azure/active-directory/reports-monitoring/reference-azure-monitor-sign-ins-log-schema
    if [raw][category] == "SignInLogs" or [raw][category] == "ManagedIdentitySignInLogs" or [raw][category] == "NonInteractiveUserSignInLogs" or [raw][category] == "ServicePrincipalSignInLogs" {
      date {
        match => [ "[raw][time]", "ISO8601" ]
      }

      mutate {
        rename => {
          "[raw][category]" => "category"
          "[raw][tenantId]" => "tenant_guid"
          "[raw][resultType]" => "result_type"
          "[raw][resultSignature]" => "result_signature"
          "[raw][resultDescription]" => "result_description"
          "[raw][callerIpAddress]" => "source_ip"
          "[raw][correlationID]" => "correlation_guid"
          "[raw][location]" => "datacenter_location"
          "[raw][operationName]" => "operation_name"
          "[raw][properties][userDisplayName]" => "user_name"
          "[raw][properties][userPrincipalName]" => "user_principal_name"
          "[raw][properties][userId]" => "user_id"
          "[raw][properties][appId]" => "application_id"
          "[raw][properties][appDisplayName]" => "application_name"
          "[raw][properties][status][errorCode]" => "error_code"
          "[raw][properties][failureReason]" => "failure_reason"
          "[raw][properties][clientAppUsed]" => "client_app_used"
          "[raw][properties][userAgent]" => "useragent"
          "[raw][properties][authenticationDetails]" => "authentication_details"
        }
        add_tag => [ "azure_json_signin_log" ]
      }
    }

    ### Azure Audit Logs, in JSON format
    # https://docs.microsoft.com/en-us/azure/active-directory/reports-monitoring/reference-azure-monitor-audit-log-schema
    if [raw][category] == "AuditLogs" or [raw][category] == "Audit" {
      date {
        match => [ "[raw][time]", "ISO8601" ]
      }

      mutate {
        rename => {
          "[raw][category]" => "category"
          "[raw][tenantId]" => "tenant_guid"
          "[raw][resourceId]" => "resource_id"
          "[raw][operationName]" => "operation_name"
          "[raw][resultSignature]" => "result_signature"
          "[raw][resultDescription]" => "result_description"
          "[raw][callerIpAddress]" => "source_ip"
          "[raw][correlationID]" => "correlation_guid"
          "[raw][identity]" => "identity"
          "[raw][properties][category]" => "property_category"
          "[raw][properties][result]" => "result"
          "[raw][properties][result_reason]" => "result_reason"
          "[raw][properties][activityDisplayName]" => "activity_display_name"
          "[raw][properties][loggedByService]" => "logged_by_service"
          "[raw][properties][operationType]" => "operation_type"
          "[raw][properties][initiatedBy][user][displayName]" => "initiating_user_display_name"
          "[raw][properties][initiatedBy][user][userPrincipalName]" => "initiating_user_principal_name"
          "[raw][properties][initiatedBy][user][ipAddress]" => "initiating_user_ip"
          "[raw][properties][initiatedBy][user][servicePrincipalId]" => "initiating_service_principal_id"
        }
        add_tag => [ "azure_json_audit_log" ]
      }

      mutate {
        remove_field => [ "initiating_user_ip" ]
      }

      # if [raw][properties][additionalDetails] {
      #   # convert the original {"key": "name", "value": "foo"} structures to
      #   # "key": "foo", reparenting into additional_details
      #   ruby {
      #     path => "/usr/local/sof-elk/supporting-scripts/split_kv_to_fields.rb"
      #     script_params => {
      #       "source_field" => "[raw][properties][additionalDetails]"
      #       "destination_field" => "[additional_details]"
      #       "key_field" => "key"
      #       "val_field" => "value"
      #     }
      #   }
      # }
    }

    ### Azure Activity Logs, in JSON format
    # https://docs.microsoft.com/en-us/azure/active-directory/reports-monitoring/reference-azure-monitor-audit-log-schema
    if [raw][category] == "Administrative" {
      date {
        match => [ "[raw][time]", "ISO8601" ]
      }

      mutate {
        rename => {
          "[raw][category]" => "category"
          "[raw][resourceId]" => "resource_id"
          "[raw][RoleLocation]" => "role_location"
          "[raw][operationName]" => "operation_name"
          "[raw][resultType]" => "result_type"
          "[raw][resultSignature]" => "result_signature"
          "[raw][callerIpAddress]" => "source_ip"
          "[raw][correlationId]" => "correlation_guid"
          "[raw][identity][authorization][scope]" => "scope"
          "[raw][identity][authorization][action]" => "action"
          "[raw][identity][authorization][evidence][role]" => "role"
          "[raw][identity][claims][http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn]" => "user_principal_name"
          "[raw][properties][responseBody]" => "response_body"
        }
        add_tag => [ "azure_json_activity_log" ]
      }
    }

    ### Azure Storage Logs - StorageRead, in JSON format
    # https://docs.microsoft.com/en-us/azure/storage/blobs/monitor-blob-storage-reference
    if [raw][category] == "StorageRead" {
      date {
        match => [ "[raw][time]", "ISO8601" ]
      }

      mutate {
        rename => {
          "[raw][resourceId]" => "resource_id"
          "[raw][category]" => "category"
          "[raw][operationName]" => "operation_name"
          "[raw][statusText]" => "status_text"
          "[raw][correlationId]" => "correlation_guid"
          "[raw][identity][type]" => "identity_type"
          "[raw][identity][tokenHash]" => "identity_token"
          "[raw][location]" => "datacenter_location"
          "[raw][properties][accountName]" => "property_accountname"
          "[raw][properties][userAgentHeader]" => "useragent"
          "[raw][properties][serviceType]" => "property_servicetype"
          "[raw][uri]" => "uri"
        }
        add_tag => [ "azure_json_storage_log"]
      }
    }

    ### Azure Storage Logs - StorageWrite, in JSON format
    # https://docs.microsoft.com/en-us/azure/storage/blobs/monitor-blob-storage-reference
    if [raw][category] == "StorageWrite" {
      date {
        match => [ "[raw][time]", "ISO8601" ]
      }

      mutate {
        rename => {
          "[raw][resourceId]" => "resource_id"
          "[raw][category]" => "category"
          "[raw][operationName]" => "operation_name"
          "[raw][statusText]" => "status_text"
          "[raw][correlationId]" => "correlation_guid"
          "[raw][identity][type]" => "identity_type"
          "[raw][identity][tokenHash]" => "identity_token"
          "[raw][location]" => "datacenter_location"
          "[raw][properties][accountName]" => "property_accountname"
          "[raw][properties][userAgentHeader]" => "useragent"
          "[raw][properties][serviceType]" => "property_servicetype"
          "[raw][uri]" => "uri"
        }
        add_tag => [ "azure_json_storage_log"]
      }
    }

    ### Azure Storage Logs - StorageDelete, in JSON format
    # https://docs.microsoft.com/en-us/azure/storage/blobs/monitor-blob-storage-reference
    if [raw][category] == "StorageDelete" {
      date {
        match => [ "[raw][time]", "ISO8601" ]
      }

      mutate {
        rename => {
          "[raw][resourceId]" => "resource_id"
          "[raw][category]" => "category"
          "[raw][operationName]" => "operation_name"
          "[raw][statusText]" => "status_text"
          "[raw][correlationId]" => "correlation_guid"
          "[raw][identity][type]" => "identity_type"
          "[raw][identity][tokenHash]" => "identity_token"
          "[raw][location]" => "datacenter_location"
          "[raw][properties][accountName]" => "property_accountname"
          "[raw][properties][userAgentHeader]" => "useragent"
          "[raw][properties][serviceType]" => "property_servicetype"
          "[raw][uri]" => "uri"
        }
        add_tag => [ "azure_json_storage_log"]
      }
    }

    ### Azure Graph API Logs, in JSON format
    # https://learn.microsoft.com/en-us/azure/azure-monitor/reference/tables/microsoftgraphactivitylogs
    if [raw][category] == "MicrosoftGraphActivityLogs" {
      date {
        match => [ "[raw][time]", "ISO8601" ]
      }

      mutate {
        rename => {
          "[raw][resourceId]" => "resource_id"
          "[raw][operationName]" => "operation_name"
          "[raw][category]" => "category"
          "[raw][tenantId]" => "tenant_guid"
          "[raw][resultSignature]" => "result_signature"
          "[raw][correlationId]" => "correlation_guid"
          "[raw][properties][apiVersion]" => "api_version"
          "[raw][properties][requestMethod]" => "request_method"
          "[raw][properties][responseStatusCode]" => "response_code"
          "[raw][properties][userAgent]" => "useragent"
          "[raw][properties][requestUri]" => "uri"
          "[raw][properties][responseSizeBytes]" => "destination_bytes"
          "[raw][properties][roles]" => "app_roles"
          "[raw][properties][tokenIssuedAt]" => "token_time"
          "[raw][properties][appId]" => "app_guid"
          "[raw][properties][servicePrincipalId]" => "serviceprincipal_guid"
        }
      }

      # split app_roles string into an array
      # https://learn.microsoft.com/en-us/graph/permissions-reference
      if [app_roles] {
        mutate {
          split => { "app_roles" => " " }
        }
      }
    }

    # break callerIpAddress into source IP and port
    if [raw][callerIpAddress] {
      grok {
        patterns_dir => [ "/usr/local/sof-elk/grok-patterns" ]
        match => {
          "[raw][callerIpAddress]" => [ "%{IP:source_ip}(?::%{INT:source_port})?" ]
        }
      }
    }

    # break out the modifiedProperties array to a kv-multi and reparent the rest of the targetResources
    if [raw][properties][targetResources][modifiedProperties] {
      # convert the original {"displayName": "foo", "oldValue": "previous", "newValue": "current"} structures to
      # foo: { "oldValue": "previous", "newValue": "current"}, reparenting into target_resource_modifications
      ruby {
        path => "/usr/local/sof-elk/supporting-scripts/split_kv_multi_to_fields.rb"
        script_params => {
          "source_field" => "[raw][properties][targetResources][modifiedProperties]"
          "destination_field" => "[target_resource_modifications]"
          "key_field" => "displayName"
        }
        remove_field => [ "[raw][properties][targetResources][modifiedProperties]" ]
      }
      mutate {
        rename => {
          "[raw][properties][targetResources]" => "target_resources"
        }
      }
    }

    # Convert the PrivilegeList entries into an array
    if [event_data][PrivilegeList] {
      mutate {
        gsub => [
          "[event_data][PrivilegeList]", "\n[ \t]+", ","
        ]
        split => {
          "[event_data][PrivilegeList]" => ","
        }
      }
    }

    # Enrich User Agent field
    if [additional_details][User-Agent] {
      mutate {
        rename => {
          "[additional_details][User-Agent]" => "useragent"
        }
      }
    }

    # Format date fields appropriately
    if [authentication_details][authenticationStepDateTime] {
      date {
        match => [ "[authentication_details][authenticationStepDateTime]", "ISO8601" ]
        target => "[authentication_details][authenticationStepDateTime]"
      }
    }
    if [token_time] {
      date {
        match => [ "[token_time]", "ISO8601" ]
        target => "[token_time]"
      }
    }

    # drop all other categories - any unhandled log entries results in a current time stamp on the unparsed record
    if [raw][category] or [raw][System][Provider][Name] {
      drop {}
    }

    # remove remaining fields
    mutate {
      remove_field => [ "raw" ]
    }
  }
}
