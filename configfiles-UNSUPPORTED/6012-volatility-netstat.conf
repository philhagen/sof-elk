# Logstash configuration for Volatility windows.netstat output
# This parser handles JSON format from Volatility3 windows.netstat plugin
# Traverses network tracking structures (similar to netstat command)
#
# Usage: Place JSON files in the input directory configured below
# Index Pattern: volatility-netstat-*

filter {
  # Only process if this is a netstat document
  if [type] == "volatility-netstat" or "volatility-netstat" in [tags] {

    # Parse JSON if it's a string
    if [message] {
      json {
        source => "message"
        target => "network"
      }
    }

    # Extract network connection information
    mutate {
      add_field => {
        "process_id" => "%{[network][PID]}"
        "process_name" => "%{[network][Owner]}"
        "network_protocol" => "%{[network][Proto]}"
        "local_address" => "%{[network][LocalAddr]}"
        "local_port" => "%{[network][LocalPort]}"
        "foreign_address" => "%{[network][ForeignAddr]}"
        "foreign_port" => "%{[network][ForeignPort]}"
        "connection_state" => "%{[network][State]}"
        "network_offset" => "%{[network][Offset]}"
      }
      add_tag => [ "volatility", "memory_forensics", "network_analysis", "netstat" ]
    }

    # Parse connection creation timestamp
    if [network][Created] {
      date {
        match => [ "[network][Created]", "ISO8601", "yyyy-MM-dd'T'HH:mm:ssZ", "yyyy-MM-dd'T'HH:mm:ss.SSSSSSZ" ]
        target => "connection_created_time"
      }
    }

    # Convert numeric fields
    mutate {
      convert => {
        "process_id" => "integer"
        "local_port" => "integer"
        "foreign_port" => "integer"
      }
    }

    # Determine IP version
    if [network_protocol] =~ /v6$/ {
      mutate {
        add_field => { "ip_version" => "IPv6" }
      }
    } else {
      mutate {
        add_field => { "ip_version" => "IPv4" }
      }
    }

    # Classify connection type
    if [network_protocol] =~ /^TCP/ {
      mutate {
        add_field => { "transport_protocol" => "TCP" }
      }
    } else if [network_protocol] =~ /^UDP/ {
      mutate {
        add_field => { "transport_protocol" => "UDP" }
      }
    }

    # Classify connection state
    if [connection_state] == "LISTENING" {
      mutate {
        add_field => { "connection_type" => "listening" }
      }
    } else if [connection_state] == "ESTABLISHED" {
      mutate {
        add_field => { "connection_type" => "established" }
      }
    } else if [connection_state] =~ /CLOSE|FIN|TIME_WAIT/ {
      mutate {
        add_field => { "connection_type" => "closing" }
      }
    }

    # Check if foreign address is external
    if [foreign_address] and [foreign_address] != "0.0.0.0" and [foreign_address] != "::" and [foreign_address] != "*" {
      if [foreign_address] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.|::1|fe80:)/ {
        mutate {
          add_field => { "connection_scope" => "external" }
          add_tag => [ "external_connection" ]
        }
      } else {
        mutate {
          add_field => { "connection_scope" => "internal" }
        }
      }
    }

    # Flag common service ports
    if [local_port] {
      if [local_port] == 80 {
        mutate { add_field => { "service_type" => "http" } }
      } else if [local_port] == 443 {
        mutate { add_field => { "service_type" => "https" } }
      } else if [local_port] == 22 {
        mutate { add_field => { "service_type" => "ssh" } }
      } else if [local_port] == 3389 {
        mutate { add_field => { "service_type" => "rdp" } }
      } else if [local_port] == 445 {
        mutate { add_field => { "service_type" => "smb" } }
      } else if [local_port] == 139 {
        mutate { add_field => { "service_type" => "netbios" } }
      } else if [local_port] == 135 {
        mutate { add_field => { "service_type" => "rpc" } }
      } else if [local_port] == 53 {
        mutate { add_field => { "service_type" => "dns" } }
      }
    }

    # Add metadata fields
    mutate {
      add_field => {
        "volatility_plugin" => "windows.netstat"
        "analysis_type" => "network_connections"
        "detection_method" => "netstat_traversal"
      }
    }

    # Mark for correlation with netscan
    mutate {
      add_tag => [ "correlate_with_netscan" ]
    }

    # GeoIP enrichment for foreign addresses
    if [foreign_address] and [connection_scope] == "external" {
      geoip {
        source => "foreign_address"
        target => "foreign_geo"
        fields => ["city_name", "country_name", "country_code2", "location", "continent_code"]
        tag_on_failure => ["_geoip_lookup_failure"]
      }
    }

    # Clean up
    mutate {
      remove_field => [ "message" ]
    }
  }
}

output {
  if [type] == "volatility-netstat" or "volatility-netstat" in [tags] {
    elasticsearch {
      hosts => ["localhost:9200"]
      index => "volatility-netstat-%{+YYYY.MM.dd}"
      document_type => "_doc"
    }
  }
}
