# SOF-ELKÂ® Configuration File
# (C)2023 Lewes Technology Consulting, LLC
#
# This file contains processing steps for Zeek's "files" logs

# Reference: https://docs.zeek.org/en/master/scripts/base/frameworks/files/main.zeek.html#type-Files::Info

filter {
  if [type] == "zeek_files" {
    if "zeek_json" not in [tags] {
      csv {
        # If you use a custom delimiter, change the following value in between the quotes to your delimiter. Otherwise, insert a literal <tab> in between the two quotes on your logstash system, use a text editor like nano that doesn't convert tabs to spaces.
        separator => "	"
        skip_empty_rows => "true"
        columns => [ "ts", "fuid", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p", "depth", "analyzers", "mime_type", "filename", "duration", "local_orig", "is_orig", "seen_bytes", "total_bytes", "missing_bytes", "overflow_bytes", "timedout", "parent_fuid", "md5", "sha1", "sha256", "x509", "extracted", "extracted_cutoff", "extracted_size", "entropy" ]
        remove_field => "message"
        target => "raw"
      }

      # this whole section is a candidate for an external ruby script that would iterate a supplied list of fields, replacing each with "0" if it's originally set to "-"
      # replace numerical fields that are needed downstream to zero if they are empty
      if [raw][duration] == "-" { mutate { replace => { "[raw][duration]" =? "0" } } }
      if [raw][seen_bytes] == "-" { mutate { replace => { "[raw][seen_bytes]" =? "0" } } }
      if [raw][missing_bytes] == "-" { mutate { replace => { "[raw][missing_bytes]" =? "0" } } }
      if [raw][overflow_bytes] == "-" { mutate { replace => { "[raw][overflow_bytes]" =? "0" } } }
      if [raw][extracted_size] == "-" { mutate { replace => { "[raw][extracted_size]" =? "0" } } }
      # remove fields that are empty if we don't need them for other calculations
      if [raw][uid] == "-" { mutate { remove_field => [ "[raw][uid]"] } }
      if [raw][id.orig_h] == "-" { mutate { remove_field => [ "[raw][id.orig_h]"] } }
      if [raw][id.orig_p] == "-" { mutate { remove_field => [ "[raw][id.orig_p]"] } }
      if [raw][id.resp_h] == "-" { mutate { remove_field => [ "[raw][id.resp_h]"] } }
      if [raw][id.resp_p] == "-" { mutate { remove_field => [ "[raw][id.resp_p]"] } }
      if [raw][source] == "-" { mutate { remove_field => [ "[raw][source]"] } }
      if [raw][depth] == "-" { mutate { remove_field => [ "[raw][depth]"] } }
      if [raw][mime_type] == "-" { mutate { remove_field => [ "[raw][mime_type]"] } }
      if [raw][filename] == "-" { mutate { remove_field => [ "[raw][filename]"] } }
      if [raw][local_orig] == "-" { mutate { remove_field => [ "[raw][local_orig]"] } }
      if [raw][is_orig] == "-" { mutate { remove_field => [ "[raw][is_orig]"] } }
      if [raw][timedout] == "-" { mutate { remove_field => [ "[raw][timedout]"] } }
      if [raw][parent_fuid] == "-" { mutate { remove_field => [ "[raw][parent_fuid]"] } }
      if [raw][md5] == "-" { mutate { remove_field => [ "[raw][md5]"] } }
      if [raw][sha1] == "-" { mutate { remove_field => [ "[raw][sha1]"] } }
      if [raw][sha256] == "-" { mutate { remove_field => [ "[raw][sha256]"] } }
      if [raw][extracted] == "-" { mutate { remove_field => [ "[raw][extracted]"] } }
      if [raw][extracted_cutoff] == "-" { mutate { remove_field => [ "[raw][extracted_cutoff]"] } }
      if [raw][entropy] == "-" { mutate { remove_field => [ "[raw][entropy]"] } }
    }

    mutate {
      rename => {
        "[raw][fuid]" => "fuid"
        "[raw][uid]" => "zeek_uid"
        "[raw][id.orig_h]" => "source_ip"
        "[raw][id.orig_p]" => "source_port"
        "[raw][id.resp_h]" => "destination_ip"
        "[raw][id.resp_p]" => "destination_port"
        "[raw][source]" => "source"
        "[raw][depth]" => "depth"
        "[raw][analyzers]" => "analyzers"
        "[raw][mime_type]" => "mime_types"
        "[raw][filename]" => "filename"
        "[raw][duration]" => "duration"
        "[raw][local_orig]" => "local_orig"
        "[raw][is_orig]" => "is_orig"
        "[raw][seen_bytes]" => "seen_bytes"
        "[raw][missing_bytes]" => "missing_bytes"
        "[raw][overflow_bytes]" => "overflow_bytes"
        "[raw][parent_fuid]" => "parent_fuid"
        "[raw][md5]" => "md5"
        "[raw][sha1]" => "sha1"
        "[raw][sha256]" => "sha256"
        "[raw][extracted]" => "extracted"
        "[raw][extracted_cutoff]" => "extracted_cutoff"
        "[raw][extracted_size]" => "extracted_size"
        "[raw][entropy]" => "entropy"
      }
    }

    # populate the @timestamp field with the ts value
    date {
      match => [ "[raw][ts]", "UNIX" ]
    }

    mutate {
      # replace the "host" field with zeroes since we are loading from an archive file.  Will need a better way to do this in the future, though
      replace => { "host" => "0.0.0.0" }
      convert => {
        "depth" => "integer"
        "duration" => "float"
        "seen_bytes" => "integer"
        "total_bytes" => "integer"
        "missing_bytes" => "integer"
        "overflow_bytes" => "integer"
        "extracted_size" => "integer"
      }
      remove_field => "raw"
    }
  }
}
