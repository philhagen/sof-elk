# SOF-ELKÂ® Configuration File
# (C)2023 Lewes Technology Consulting, LLC
#
# This file contains processing steps for Zeek's DNS logs, normalizing them to existing mapppings for other DNS records
# Some portions orginally contributed by Justin Henderson

# Reference: https://docs.zeek.org/en/master/scripts/base/protocols/dns/main.zeek.html#type-DNS::Info

filter {
  if [type] == "zeek_dns" {
    if "zeek_json" not in [tags] {
      # This is the initial parsing of the log
      csv {
        # If you use a custom delimiter, change the following value in between the quotes to your delimiter. Otherwise, insert a literal <tab> in between the two quotes on your logstash system, use a text editor like nano that doesn't convert tabs to spaces.
        separator => "  "
        skip_empty_rows => "true"
        columns => [ "ts", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p", "proto", "trans_id", "rtt", "query", "qclass", "qclass_name", "qtype", "qtype_name", "rcode", "rcode_name", "AA", "TC", "RD", "RA", "Z", "answers", "TTLs", "rejected" ]
        remove_field => "message"
        target => "raw"
      }

      # this whole section is a candidate for an external ruby script that would iterate a supplied list of fields, replacing each with "0" if it's originally set to "-"
      # remove fields that are empty if we don't need them for other calculations
      if [raw][trans_id] == "-" { mutate { remove_field => [ "[raw][trans_id]"] } }
      if [raw][rtt] == "-" { mutate { remove_field => [ "[raw][rtt]"] } }
      if [raw][query] == "-" { mutate { remove_field => [ "[raw][query]"] } }
      if [raw][qclass] == "-" { mutate { remove_field => [ "[raw][qclass]"] } }
      if [raw][qclass_name] == "-" { mutate { remove_field => [ "[raw][qclass_name]"] } }
      if [raw][qtype] == "-" { mutate { remove_field => [ "[raw][qtype]"] } }
      if [raw][qtype_name] == "-" { mutate { remove_field => [ "[raw][qtype_name]"] } }
      if [raw][rcode] == "-" { mutate { remove_field => [ "[raw][rcode]"] } }
      if [raw][rcode_name] == "-" { mutate { remove_field => [ "[raw][rcode_name]"] } }
      if [raw][AA] == "-" { mutate { remove_field => [ "[raw][AA]"] } }
      if [raw][TC] == "-" { mutate { remove_field => [ "[raw][TC]"] } }
      if [raw][RD] == "-" { mutate { remove_field => [ "[raw][RD]"] } }
      if [raw][RA] == "-" { mutate { remove_field => [ "[raw][RA]"] } }
      if [raw][Z] == "-" { mutate { remove_field => [ "[raw][Z]"] } }
# these are arrays - not sure how to detect "empty" in TSV
#      if [raw][answers] == "-" { mutate { remove_field => [ "[raw][answers]"] } }
#      if [raw][TTLs] == "-" { mutate { remove_field => [ "[raw][TTLs]"] } }
      if [raw][rejected] == "-" { mutate { remove_field => [ "[raw][rejected]"] } }

      mutate {
        split => {
          "[raw][answers]" => ","
          "[raw][TTLs]" => ","
        }
      }
    }

    mutate {
      rename => {
        "[raw][uid]" => "zeek_uid"
        "[raw][id.orig_h]" => "source_ip"
        "[raw][id.orig_p]" => "source_port"
        "[raw][id.resp_h]" => "destination_ip"
        "[raw][id.resp_p]" => "destination_port"
        "[raw][proto]" => "aprotocol"
        "[raw][query]" => "query"
        "[raw][qtype_name]" => "query_type"
        "[raw][answers]" => "answer"
        "[raw][TTLs]" => "ttl"
        "[raw][rcode_name]" => "response_code"
        "[raw][trans_id]" => "transaction_id"
        "[raw][rtt]" => "rtt"
        "[raw][AA]" => "[dns_flags][authoritative]"
        "[raw][TC]" => "[dns_flags][truncated]"
        "[raw][RD]" => "[dns_flags][recursion_desired]"
        "[raw][RA]" => "[dns_flags][recursion_available]"
        "[raw][Z]" => "[dnssec_z]"
        "[raw][rejected]" => "[dns_flags][rejected]"
      }
    }

    if [raw][qclass_name] {
      translate {
        dictionary_path => "/usr/local/sof-elk/lib/dictionaries/zeek_dns_class2classabbrev.yaml"
        source => "qclass_name"
        target => "query_class"
      }
    }

    # populate the @timestamp field with the ts value
    date {
      match => [ "[raw][ts]", "UNIX" ]
    }
    translate {
      dictionary_path => "/usr/local/sof-elk/lib/dictionaries/ip_proto_zeek2int.yaml"
      source => "aprotocol"
      target => "protocol"
    }

    if [answer] and [query_type] != "CNAME" {
      grok {
        match => [ "answer", "^%{IP:answer_ip}$" ]
      }
    }

    if [source_ip] and [query] and [answer] {
      mutate {
        replace => { "message" => "DNS: %{source_ip} (%{query} -> %{answer})" }
      }
    } else if [source_ip] and [query] {
      mutate {
        replace => { "message" => "DNS: %{source_ip} (%{query} -> No response)"}
      }
    }

    mutate {
      # replace the "host" field with zeroes since we are loading from an archive file.  Will need a better way to do this in the future, though
      replace => { "host" => "0.0.0.0" }
      convert => {
        "protocol" => "integer"
      }
      remove_field => "raw"
    }
  }
}
