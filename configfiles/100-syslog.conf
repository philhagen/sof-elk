# SOF-ELK Configuration File
# (C)2016 Lewes Technology Consulting, LLC
#
# This file contains filters, transforms, and enrichments for basic syslog parsing

filter {
    if "process_syslog" in [tags] and "process_live" in [tags] {
        mutate {
            rename => [ "program", "syslog_program" ]
            rename => [ "logsource", "syslog_hostname" ]
            rename => [ "pid", "syslog_pid" ]
            rename => [ "timestamp", "syslog_timestamp" ]
            add_tag => [ "got_syslog_timestamp", "got_syslog_hostname", "got_syslog_program" ]
            ### DEBUG
            ###add_field => { "orig_message" => "%{message}" }
        }
    }

    if "process_syslog" in [tags] {
        if "syslog" in [tags] {
            mutate {
                add_field => { "path" => "syslog from %{host}" }
            }
        } else if "relp" in [tags] {
            mutate {
                add_field => { "path" => "relp from %{host}" }
            }
        } else if "filebeat" in [tags] {
            mutate {
                add_field => { "path" => "filebeat from %{host}: %{source}" }
            }
        } else if !("file" in [tags]) {
            mutate {
                add_field => { "path" => "unknown syslog source" }
            }
        }
    }

    # Check if syslog message has PRI.     If so then :
    #  strip the syslog PRI part and create facility and severity fields.
    #  the extracted PRI is available in the %{syslog_pri} field.
    #
    #  You get %{syslog_facility_code} and %{syslog_severity_code} fields.
    #  You also get %{syslog_facility} and %{syslog_severity} fields if the
    #  use_labels option is set True (the default) on syslog_pri filter.
    if "process_syslog" in [tags] and "process_archive" in [tags] and [message] =~ /^<\d+>/ {
        mutate { add_tag => [ "has_pri" ] }
    }

    if "process_syslog" in [tags] and "process_archive" in [tags] and "has_pri" in [tags] {
        grok {
            match => [ "message", "<%{POSINT:syslog_pri}>%{SPACE}%{GREEDYDATA:message_remainder}" ]
            add_tag => [ "got_syslog_pri" ]
            tag_on_failure => [ "_gpfail", "fail_sl01" ]
        }
    }

    if "process_syslog" in [tags] and "process_archive" in [tags] and "got_syslog_pri" in [tags] and [message_remainder] and [message_remainder] != "" {
        mutate {
            replace => [ "message", "%{message_remainder}" ]
        }
    } else if "process_syslog" in [tags] and "process_archive" in [tags] and "got_syslog_pri" in [tags] {
        mutate {
            replace => [ "message", "<null message>" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_pri" in [tags] {
        mutate {
            # XXX must not be combined with replacement which uses same field
            remove_field => [ "message_remainder" ]
        }
        syslog_pri {
            use_labels => false
            add_tag => [ "rename_priority_fields" ]
        }
    }

    if "rename_priority_fields" in [tags] {
        mutate {
            rename => [ "syslog_facility_code", "facility" ]
            rename => [ "syslog_severity_code", "severity" ]
            remove_tag => [ "rename_priority_fields", "got_syslog_pri" ]
            remove_field => [ "syslog_pri" ]
        }
    }

    # strip the syslog timestamp and force event timestamp to be the same.
    # the original string is saved in field %{syslog_timestamp}.
    # the original logstash input timestamp is saved in field %{received_at}.
    if "process_syslog" in [tags] and "process_archive" in [tags] {
        grok {
            patterns_dir => "/usr/local/sof-elk/grok-patterns"
            match => [ "message", "%{FULLSYSLOGTIMESTAMP:syslog_timestamp}%{SPACE}%{GREEDYDATA:message_remainder}" ]
            add_tag => [ "got_syslog_timestamp" ]
            add_field => { "received_at" => "%{@timestamp}" }
            tag_on_failure => [ "_gpfail", "fail_sl02" ]
        }
    }

    if "process_syslog" in [tags] and "process_archive" in [tags] and "file" in [tags] {
        grok {
            match => [ "path", "\/%{YEAR:path_year}\/" ]
            add_tag => [ "got_path_year" ]
            tag_on_failure => [ "_gpfail", "fail_sl03" ]
        }
    }

    if "got_path_year" in [tags] {
        mutate {
            replace => [ "syslog_timestamp", "%{syslog_timestamp} %{path_year}" ]
            remove_field => "path_year"
        }
    }

    if "process_syslog" in [tags] and "got_syslog_timestamp" in [tags] and [message_remainder] and [message_remainder] != "" {
        mutate {
            replace => [ "message", "%{message_remainder}" ]
        }
    } else if "process_syslog" in [tags] and "got_syslog_timestamp" in [tags] {
        mutate {
            replace => [ "message", "<null message>" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_timestamp" in [tags] {
        mutate {
            # XXX must not be combined with replacement which uses same field
            remove_field => [ "message_remainder" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_timestamp" in [tags] {
        date {
            # season to taste for your own syslog format(s)
            # RFC3339 via rsyslog is "2016-05-10T01:49:03.863938+00:00"
            match => [ "syslog_timestamp", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss", "ISO8601", "MMM dd HH:mm:ss yyyy", "MMM  d HH:mm:ss yyyy" ]
        }
    }

    # strip the host field from the syslog line.
    # the extracted host field becomes the logstash %{host} metadata
    # and is also available in the field %{syslog_hostname}.
    # the original logstash host is saved in field %{logstash_source}.
    if "process_syslog" in [tags] {
        grok {
            patterns_dir => "/usr/local/sof-elk/grok-patterns"
            match => [ "message", "%{SYSLOGHOST:syslog_hostname}%{SPACE}%{GREEDYDATA:message_remainder}" ]
            add_tag => [ "got_syslog_hostname" ]
            add_field => { "logstash_source" => "%{host}" }
            tag_on_failure => [ "_gpfail", "fail_sl04" ]
        }
    }

    if "got_syslog_hostname" in [tags] {
        mutate {
            lowercase => [ "syslog_hostname" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_hostname" in [tags] and [message_remainder] and [message_remainder] != "" {
        mutate {
            replace => [ "host", "%{syslog_hostname}" ]
            replace => [ "message", "%{message_remainder}" ]
        }
    } else if "process_syslog" in [tags] and "got_syslog_hostname" in [tags] {
        mutate {
            replace => [ "message", "<null message>" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_hostname" in [tags] {
        mutate {
            # message_remainder no longer needed.
            remove_field => [ "message_remainder" ]
        }
    }

    # strip the program and optional pid field from the syslog line.
    # available in the field %{syslog_program} and %{syslog_pid}.
    # note that we do NOT do this for live syslog, as the value has already been provided by the syslog input handler
    if "process_syslog" in [tags] {
        grok {
            patterns_dir => "/usr/local/sof-elk/grok-patterns"
            match => [ "message", "^%{PROG:syslog_program}(?:\[%{POSINT:syslog_pid}\])?:%{SPACE}%{GREEDYDATA:message_remainder}" ]
            add_tag => [ "got_syslog_program", "got_syslog_pid" ]
            tag_on_failure => [ "_gpfail", "fail_sl05" ]
        }
    }

    if "got_syslog_program" in [tags] {
        mutate {
            lowercase => [ "syslog_program" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_program" in [tags] and [message_remainder] and [message_remainder] != "" and !( "parse_done" in [tags] ) {
        mutate {
            replace => [ "message", "%{message_remainder}" ]
        }

    } else if "process_syslog" in [tags] and "got_syslog_program" in [tags] {
        mutate {
            replace => [ "message", "<null message>" ]
        }
    }

    if "process_syslog" in [tags] and "got_syslog_program" in [tags] and !( "parse_done" in [tags] ) {
        mutate {
            # message_remainder no longer needed.
            remove_field => [ "message_remainder" ]
        }
    }
}