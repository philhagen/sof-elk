# SOF-ELKÂ® Configuration File
# (C)2023 Lewes Technology Consulting, LLC
#
# This file contains processing steps for Zeek's connection logs, normalizing them to existing netflow mapppings
# Some portions orginally contributed by Justin Henderson

# Reference: https://docs.zeek.org/en/master/scripts/base/protocols/conn/main.zeek.html#type-Conn::Info

filter {
  if [type] == "zeek_conn" {
    if "zeek_json" not in [tags] {
      # This is the initial parsing of the log
      csv {
        # If you use a custom delimiter, change the following value in between the quotes to your delimiter.
        #   Otherwise, insert a literal <tab> in between the two quotes on your logstash system.
        #   Use a text editor like nano that doesn't convert tabs to spaces.
        separator => "	"
        skip_empty_rows => "true"
        columns => [ "ts", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p", "proto", "service", "duration", "orig_bytes", "resp_bytes", "conn_state", "local_orig", "local_resp", "missed_bytes", "history", "orig_pkts", "orig_ip_bytes", "resp_pkts", "resp_ip_bytes", "tunnel_parents" ]
        remove_field => "message"
        target => "raw"
      }

      # this whole section is a candidate for an external ruby script that would iterate a supplied list of fields, replacing each with "0" if it's originally set to "-"
      # replace numerical fields that are needed downstream to zero if they are empty
      if [raw][orig_bytes] == "-" { mutate { replace => { "[raw][orig_bytes]" => "0" } } }
      if [raw][resp_bytes] == "-" { mutate { replace => { "[raw][resp_bytes]" => "0" } } }
      if [raw][missed_bytes] == "-" { mutate { replace => { "[raw][missed_bytes]" => "0" } } }
      if [raw][orig_pkts] == "-" { mutate { replace => { "[raw][orig_pkts]" => "0" } } }
      if [raw][orig_ip_bytes] == "-" { mutate { replace => { "[raw][orig_ip_bytes]" => "0" } } }
      if [raw][resp_pkts] == "-" { mutate { replace => { "[raw][resp_pkts]" => "0"} } }
      if [raw][resp_ip_bytes] == "-" { mutate { replace => { "[raw][resp_ip_bytes]" => "0" } } }
      # remove fields that are empty if we don't need them for other calculations
      if [raw][service] == "-" { mutate { remove_field => [ "[raw][service]" ] } }
      if [raw][duration] == "-" { mutate { remove_field => [ "[raw][duration]" ] } }
      if [raw][conn_state] == "-" { mutate { remove_field => [ "[raw][conn_state]" ] } }
      if [raw][local_orig] == "-" { mutate { remove_field => [ "[raw][local_orig]" ] } }
      if [raw][local_resp] == "-" { mutate { remove_field => [ "[raw][local_resp]" ] } }
      if [raw][history] == "-" { mutate { remove_field => [ "[raw][history]" ] } }
      if [raw][ip.orig_p] == "-" { mutate { remove_field => [ "[raw][ip.orig_p]"] } }
      if [raw][ip.resp_p] == "-" { mutate { remove_field => [ "[raw][ip.resp_p]"] } }
      if [raw][tunnel_parents] == "-" { mutate { remove_field => [ "[raw][tunnel_parents]"] } }
    }

    mutate {
      rename => {
        "[raw][uid]" => "zeek_uid"
        "[raw][id.orig_h]" => "source_ip"
        "[raw][id.orig_p]" => "source_port"
        "[raw][id.resp_h]" => "destination_ip"
        "[raw][id.resp_p]" => "destination_port"
        "[raw][proto]" => "aprotocol"
        "[raw][service]" => "zeek_service"
        "[raw][duration]" => "flow_duration"
        "[raw][orig_bytes]" => "out_bytes"
        "[raw][resp_bytes]" => "in_bytes"
        "[raw][conn_state]" => "zeek_conn_state"
        "[raw][local_orig]" => "zeek_local_source"
        "[raw][local_resp]" => "zeek_local_destination"
        "[raw][missed_bytes]" => "missed_bytes"
        "[raw][history]" => "zeek_history"
        "[raw][orig_pkts]" => "out_packets"
        "[raw][orig_ip_bytes]" => "out_ip_bytes"
        "[raw][resp_pkts]" => "in_packets"
        "[raw][resp_ip_bytes]" => "in_ip_bytes"
        "[raw][tunnel_parents]" => "zeek_tunnel_parents"
        "[raw][community_id]" => "community_id"
        "[raw][orig_l2_addr]" => "out_src_mac"
        "[raw][resp_l2_addr]" => "in_src_mac"
        "[raw][vlan]" => "destination_vlan"
      }

      # add fields needed for data consistency with other netflow sources
      add_field => {
        "exporter" => "0.0.0.0"
        "flow_records" => "1"
      }
    }
    # populate additional fields or modify as needed to match flow sources
    if ![missed_bytes] {
      mutate {
        add_field => { "missed_bytes" => "0" }
      }
    }
    if ![in_bytes] {
      mutate {
        add_field => { "in_bytes" => "0" }
      }
    }
    if ![in_packets] {
      mutate {
        add_field => { "in_packets" => "0" }
      }
    }
    if ![out_bytes] {
      mutate {
        add_field => { "out_bytes" => "0" }
      }
    }
    if ![out_packets] {
      mutate {
        add_field => { "out_packets" => "0" }
      }
    }

    # populate the @timestamp field with the ts value
    date {
      match => [ "[raw][ts]", "UNIX" ]
    }

    # if there is no duration, it's zero so the start and end times are the same as @timestamp
    # use "0.0" to force this into a float later
    if ![flow_duration] {
      mutate {
        add_field => {
          "flow_duration" => "0.0"
          "flow_start" => "%{@timestamp}"
          "flow_end" => "%{@timestamp}"
        }
      }

    # otherwise, calculate the end time from @timestamp+flow_duration and then set start time to @timestamp
    } else {
      ruby {
        init => "require 'date'"
        code => "event.set('flow_end', Time.at(event.get('@timestamp').to_f + event.get('flow_duration').to_f))"
        add_field => {
          "flow_start" => "%{@timestamp}"
        }
        add_tag => [ "calculated_flow_end" ]
      }
    }

    translate {
      dictionary_path => "/usr/local/sof-elk/lib/dictionaries/ip_proto_zeek2int.yaml"
      source => "aprotocol"
      target => "protocol"
    }

    # note that we don't have native tcp flag info, but this can generally be derived from the "zeek_history" field
    # at some point in the future, this may be suitable for a ruby{} or translate{} conversion but that will take some research and validation

    if [zeek_conn_state] {
      translate {
        dictionary_path => "/usr/local/sof-elk/lib/dictionaries/zeek_connection_state2desc.yaml"
        source => "[zeek_conn_state]"
        target => "[zeek_conn_state_description]"
      }
    }

    mutate {
      convert => {
        "protocol" => "integer"
        "in_bytes" => "integer"
        "in_ip_bytes" => "integer"
        "out_bytes" => "integer"
        "out_ip_bytes" => "integer"
        "flow_records" => "integer"
        "in_packets" => "integer"
        "out_packets" => "integer"
        "missed_bytes" => "integer"
      }
      remove_field => "raw"
    }
  }
}
