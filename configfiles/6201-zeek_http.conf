# SOF-ELKÂ® Configuration File
# (C)2023 Lewes Technology Consulting, LLC
#
# This file contains processing steps for Zeek's HTTP logs, normalizing them to existing mappings for other HTTP records
# Some portions orginally contributed by Justin Henderson

# Reference: https://docs.zeek.org/en/master/scripts/base/protocols/http/main.zeek.html#type-HTTP::Info

filter {
  if [type] == "zeek_http" {
    if "zeek_json" not in [tags] {
      # This is the initial parsing of the log

      # Found numerous instances of the " character in URLs, but not in encoded form.
      # This particular character is a problem due to the Logstash CSV filter, which uses the " character as the default field quoting character.
      # May need to replace these with their URI-encoded equivalents as identified.
      mutate {
        gsub => [
          "message", '"', "%23"
        ]
      }
      csv {
        # If you use a custom delimiter, change the following value in between the quotes to your delimiter. Otherwise, insert a literal <tab> in between the two quotes on your logstash system, use a text editor like nano that doesn't convert tabs to spaces.
        separator => "	"
        skip_empty_rows => "true"
        columns => [ "ts", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p", "trans_depth", "method", "host", "uri", "referrer", "version", "user_agent", "origin", "request_body_len", "response_body_len", "status_code", "status_msg", "info_code", "info_msg", "tags", "username", "password", "capture_password", "proxied", "range_request", "orig_fuids", "orig_filenames", "orig_mime_types", "resp_fuids", "resp_filenames", "resp_mime_types", "current_entity", "orig_mime_depth", "resp_mime_depth" ]
        remove_field => "message"
        target => "raw"
      }

      # this whole section is a candidate for an external ruby script that would iterate a supplied list of fields, replacing each with "0" if it's originally set to "-"
      # replace numerical fields that are needed downstream to zero if they are empty
      if [raw][request_body_len] == "-" { mutate { replace => { "[raw][request_body_len]" => "0" } } }
      if [raw][response_body_len] == "-" { mutate { replace => { "[raw][response_body_len]" => "0" } } }
      if [raw][orig_mime_depth] == "-" { mutate { replace => { "[raw][orig_mime_depth]" => "0" } } }
      if [raw][resp_mime_depth] == "-" { mutate { replace => { "[raw][resp_mime_depth]" => "0" } } }
      if [raw][range_request] == "-" { mutate { replace => { "[raw][range_request]" => "false" } } }
      # remove fields that are empty if we don't need them for other calculations
      if [raw][method] == "-" { mutate { remove_field => [ "[raw][method]"] } }
      if [raw][host] == "-" { mutate { remove_field => [ "[raw][host]"] } }
      if [raw][uri] == "-" { mutate { remove_field => [ "[raw][uri]"] } }
      if [raw][referrer] == "-" { mutate { remove_field => [ "[raw][referrer]"] } }
      if [raw][version] == "-" { mutate { remove_field => [ "[raw][version]"] } }
      if [raw][user_agent] == "-" { mutate { remove_field => [ "[raw][user_agent]"] } }
      if [raw][origin] == "-" { mutate { remove_field => [ "[raw][origin]"] } }
      if [raw][status_code] == "-" { mutate { remove_field => [ "[raw][status_code]"] } }
      if [raw][status_msg] == "-" { mutate { remove_field => [ "[raw][status_msg]"] } }
      if [raw][info_code] == "-" { mutate { remove_field => [ "[raw][info_code]"] } }
      if [raw][info_msg] == "-" { mutate { remove_field => [ "[raw][info_msg]"] } }
      if [raw][tags] == "(empty)" { mutate { remove_field => [ "[raw][tags]"] } }
      if [raw][username] == "-" { mutate { remove_field => [ "[raw][username]"] } }
      if [raw][password] == "-" { mutate { remove_field => [ "[raw][password]"] } }
      if [raw][capture_password] == "-" { mutate { remove_field => [ "[raw][capture_password]"] } }
      if [raw][proxied] == "-" { mutate { remove_field => [ "[raw][proxied]"] } }
      if [raw][orig_fuids] == "-" { mutate { remove_field => [ "[raw][orig_fuids]"] } }
      if [raw][orig_filenames] == "-" { mutate { remove_field => [ "[raw][orig_filenames]"] } }
      if [raw][orig_mime_types] == "-" { mutate { remove_field => [ "[raw][orig_mime_types]"] } }
      if [raw][resp_fuids] == "-" { mutate { remove_field => [ "[raw][resp_fuids]"] } }
      if [raw][resp_filenames] == "-" { mutate { remove_field => [ "[raw][resp_filenames]"] } }
      if [raw][resp_mime_types] == "-" { mutate { remove_field => [ "[raw][resp_mime_types]"] } }
      if [raw][current_entity] == "-" { mutate { remove_field => [ "[raw][current_entity]"] } }
    }

    # in some odd cases, records exist with just the response values - drop these, as they are not useful
    if ![raw][method] and ![raw][host] and ![raw][uri] {
      drop { }
    }

    mutate {
      rename => {
        "[raw][host]" => "hostname"
        "[raw][id.orig_h]" => "source_ip"
        "[raw][id.orig_p]" => "source_port"
        "[raw][id.resp_h]" => "destination_ip"
        "[raw][id.resp_p]" => "destination_port"
        "[raw][info_code]" => "response_code"
        "[raw][info_msg]" => "response_msg"
        "[raw][method]" => "request_method"
        "[raw][orig_filenames]" => "zeek_source_filenames"
        "[raw][orig_fuids]" => "zeek_source_fuids"
        "[raw][orig_mime_types]" => "zeek_source_mime_types"
        "[raw][password]" => "password"
        "[raw][proxied]" => "proxy_headers"
        "[raw][referrer]" => "referrer"
        "[raw][request_body_len]" => "source_bytes"
        "[raw][resp_filenames]" => "zeek_destination_filenames"
        "[raw][resp_fuids]" => "zeek_destination_fuids"
        "[raw][resp_mime_depth]" => "zeek_destination_mime_types"
        "[raw][response_body_len]" => "destination_bytes"
        "[raw][status_code]" => "response_code"
        "[raw][status_msg]" => "response_phrase"
        "[raw][uid]" => "zeek_uid"
        "[raw][uri]" => "request"
        "[raw][user_agent]" => "useragent"
        "[raw][username]" => "username"
        "[raw][version]" => "httpversion"
      }
    }

    # these are defined by zeek but not handled at this time
    #"trans_depth", "origin", "tags", "capture_password", "range_request"
    #"orig_mime_depth", "resp_mime_depth", "current_entity"

    # populate the @timestamp field with the ts value
    date {
      match => [ "[raw][ts]", "UNIX" ]
    }

    mutate {
      convert => {
        "httpversion" => "float"
        "response_code" => "integer"
        "source_bytes" => "integer"
        "destination_bytes" => "integer"
      }
      remove_field => "raw"
    }
  }
}
