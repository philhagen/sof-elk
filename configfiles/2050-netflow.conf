# SOF-ELKÂ® Configuration File
# (C)2023 Lewes Technology Consulting, LLC
#
# This file contains filters, transforms, and enrichments for NetFlow records

filter {
  # tag with any known uniquely-identifying characteristics are present
  if [type] == "archive-netflow" and [raw][logName] {
    mutate {
      add_tag => [ "gcp-vpcflow" ]
      add_field => { "[cloud][provider]" => "gcp" }
    }
  }

  if [type] == "archive-netflow" and "gcp-vpcflow" not in [tags] {
    # drop the header row and NODATA rows from Amazon VPC Flow entries
    if [message] =~ "^version"  or [message] =~ "^account-id" or [message] =~ "NODATA" { drop { } }

    grok {
      patterns_dir => [ "/usr/local/sof-elk/grok-patterns" ]
      match => { "message" => [
        # nfdump2sof-elk.sh
        "(?:%{IPORHOST:netflow.exporter.address})?(?:%{SPACE})?%{NONNEGINT:destination.as.number:int}%{SPACE}%{NONNEGINT:destination.netmask:int}%{SPACE}%{NONNEGINT:netflow.engine_type:int}/%{NONNEGINT:netflow.engine_id:int}%{SPACE}%{TIMESTAMP_NETFLOW:flow_start_raw}%{SPACE}%{NONNEGINT:netflow.delta_flow_count}%{SPACE}%{NONNEGINT}%{SPACE}%{NONNEGINT:destination.bytes}%{SPACE}%{NONNEGINT:destination.packets}%{SPACE}%{NONNEGINT:observer.input.interface.id:int}%{SPACE}%{IP:destination.ip}%{SPACE}%{IP:next_hop.ip}%{SPACE}%{IP:source.ip}%{SPACE}(%{ICMP_TYPECODE}|%{NONNEGINT:destination.port:int})%{SPACE}%{NONNEGINT:source.port:int}%{SPACE}%{TIMESTAMP_NETFLOW:flow_end_raw}%{SPACE}%{NONNEGINT:observer.output.interface.id:int}%{SPACE}%{INT:network.iana_number:int}%{SPACE}%{NONNEGINT}%{SPACE}%{NONNEGINT}%{SPACE}%{NONNEGINT:source.as.number:int}%{SPACE}%{NONNEGINT:source.netmask:int}%{SPACE}%{NONNEGINT:source.tos:int}%{SPACE}%{NOTSPACE:netflow.tcp_flags_str}%{SPACE}%{NONNEGINT:netflow.exporter.version:int}",

        # aws-vpcflow2sof-elk.sh
        "%{INT:aws.vpcflow.version} %{INT:aws.vpcflow.account_id} %{NOTSPACE:aws.vpcflow.interface_id} %{IP:source.ip} %{IP:destination.ip} %{INT:source.port} %{INT:destination.port} %{INT:network.iana_number:int} %{INT:destination.packets} %{INT:destination.bytes} %{INT:flow_start_raw} %{INT:flow_end_raw} %{WORD:aws.vpcflow.action} %{WORD:aws.vpcflow.log_status}",
        # AWS VPC Flow v5
        "%{INT:aws.vpcflow.account_id} %{WORD:aws.vpcflow.action} %{NOTSPACE:cloud.availability_zone} %{INT:destination.bytes} %{IP:destination.ip} %{INT:destination.port} %{INT:flow_end_raw} %{WORD:network.direction} %{NOTSPACE:aws.vpcflow.instance_id} %{NOTSPACE:aws.vpcflow.interface_id} %{WORD:aws.vpcflow.log_status} %{INT:destination.packets} %{NOTSPACE:aws.vpcflow.destination_service} %{IP:original_destination.ip} %{NOTSPACE:aws.vpcflow.source.service} %{IP:original_source.ip} %{INT:network.iana_number:int} %{NOTSPACE:cloud.region} %{IP:source.ip} %{INT:source.port} %{INT:flow_start_raw} %{NOTSPACE:aws.vpcflow.vpc_id} %{INT:aws.vpcflow.version} %{WORD:aws.vpcflow.type} %{NOTSPACE:aws.vpcflow.traffic_path} %{INT:netflow.tcp_control_bits} %{NOTSPACE:aws.vpcflow.subnet_id} %{NOTSPACE:aws.vpcflow.sublocation.type} %{NOTSPACE:aws.vpcflow.sublocation.id}",

        # azure-vpcflow2sof-elk.sh
        "^%{GUID:exporter.guid},%{COMMONMAC:exporter.mac},%{POSINT:aws.vpcflow.version},%{DATA:azure.flow_rule},%{DATA:azure.flow_source_file},%{WORD:azure.flow_state},%{POSINT:flow_start_raw},%{POSINT:flow_end_raw},%{IP:source.ip},%{INT:source.port},%{IP:destination.ip},%{INT:destination.port},%{INT:network.iana_number:int},%{INT:source.bytes},%{INT:source.packets},%{INT:destination.bytes},%{INT:destination.packets},%{INT:network.direction},%{WORD:event.type}"
        ]
      }
      remove_field => [ "message", "MSECOND" ]
    }

  # Google Compute Platform VPC Flow Logs in JSON format
  # reference: https://cloud.google.com/vpc/docs/flow-logs#VpcDetails
  } else if [type] == "archive-netflow" and "gcp-vpcflow" in [tags] {
    mutate {
# todo: these seem superfluous or duplicative of [gcp][*][vpc][vpc_name]
#        "[raw][jsonPayload][src_instance][vm_name]" => "[cloud][origin][instance][name]"
#        "[raw][jsonPayload][dest_instance][vm_name]" => "[cloud][target][instance][name]"
      rename => {
        "[raw][jsonPayload][start_time]" => "flow_start_raw"
        "[raw][jsonPayload][end_time]" => "flow_end_raw"
        "[raw][jsonPayload][connection][src_ip]" => "[source][ip]"
        "[raw][jsonPayload][connection][dest_ip]" => "[destination][ip]"
        "[raw][jsonPayload][connection][src_port]" => "[source][port]"
        "[raw][jsonPayload][connection][dest_port]" => "[destination][port]"
        "[raw][jsonPayload][connection][protocol]" => "[network][iana_number]"
        "[raw][jsonPayload][bytes_sent]" => "[source][bytes]"
        "[raw][jsonPayload][packets_sent]" => "[source][packets]"
        "[raw][jsonPayload][src_instance][project_id]" => "[gcp][source][instance][project_id]"
        "[raw][jsonPayload][src_instance][region]" => "[gcp][source][instance][region]"
        "[raw][jsonPayload][src_instance][zone]" => "[gcp][source][instance][zone]"
        "[raw][jsonPayload][dest_instance][project_id]" => "[gcp][destination][instance][project_id]"
        "[raw][jsonPayload][dest_instance][region]" => "[gcp][destination][instance][region]"
        "[raw][jsonPayload][dest_instance][zone]" => "[gcp][destination][instance][zone]"
        "[raw][jsonPayload][src_vpc][project_id]" => "[gcp][source][vpc][project][id]"
        "[raw][jsonPayload][src_vpc][subnetwork_name]" => "[gcp][source][vpc][subnetwork_name]"
        "[raw][jsonPayload][src_vpc][vpc_name]" => "[gcp][source][vpc][vpc_name]"
        "[raw][jsonPayload][dest_vpc][project_id]" => "[gcp][destination][vpc][project][id]"
        "[raw][jsonPayload][dest_vpc][subnetwork_name]" => "[gcp][destination][vpc][subnetwork_name]"
        "[raw][jsonPayload][dest_vpc][vpc_name]" => "[gcp][destination][vpc][vpc_name]"
        "[raw][jsonPayload][src_location][asn]" => "[source][as][number]"
        "[raw][jsonPayload][dest_location][asn]" => "[destination][as][number]"
        "[raw][jsonPayload][reporter]" => "[gcp][vpcflow][reporter]"
        "[raw][logName]" => "log_name"
        "[raw][resource][labels][location]" => "resource_location"
        "[raw][resource][project_id]" => "project_id"
        "[raw][resource][subnetwork_id]" => "subnetwork_id"
        "[raw][resource][subnetwork_name]" => "subnetwork_name"
        "[raw][resource][type]" => "resource_type"
      }
    }
    if [gcp][vpcflow][reporter] == "SRC" {
      mutate {
        add_field => { "[netflow][exporter][address]" => "%{[source][ip]}" }
      }
    } else if [gcp][vpcflow][reporter] == "DEST" {
      mutate {
        add_field => { "[netflow][exporter][address]" => "%{[destination][ip]}" }
      }
    }

    # remove remaining fields
    mutate {
      remove_field => [ "raw" ]
    }
  }

  if [type] == "archive-netflow" {
    if ![netflow][exporter][address] {
      mutate {
        replace => {
          "[netflow][exporter][address]" => "0.0.0.0:0"
        }
      }
    }
  }

  if [type] == "netflow" {
    # get the most granular timestamps possible, but convert to floating point seconds
    if [netflow][flow_start_nanoseconds] and [netflow][flow_end_nanoseconds] {
      mutate {
        add_field => {
          "flow_start_raw" => "%{[netflow][flow_start_nanoseconds]}"
          "flow_end_raw" => "%{[netflow][flow_end_nanoseconds]}"
        }
      }
      ruby {
        code => "event.set('flow_start_raw', event.get('flow_start_raw').to_i / 1000000000); event.set('flow_end_raw', event.get('flow_end_raw').to_i / 1000000000)"
      }
    } else if [netflow][flow_start_microseconds] and [netflow][flow_end_microseconds] {
      mutate {
        add_field => {
          "flow_start_raw" => "%{[netflow][flow_start_microseconds]}"
          "flow_end_raw" => "%{[netflow][flow_end_microseconds]}"
        }
      }
      ruby {
        code => "event.set('flow_start_raw', event.get('flow_start_raw').to_i / 1000000); event.set('flow_end_raw', event.get('flow_end_raw').to_i / 1000000)"
      }
    } else if [netflow][flow_start_milliseconds] and [netflow][flow_end_milliseconds] {
      mutate {
        add_field => {
          "flow_start_raw" => "%{[netflow][flow_start_milliseconds]}"
          "flow_end_raw" => "%{[netflow][flow_end_milliseconds]}"
        }
      }
      ruby {
        code => "event.set('flow_start_raw', event.get('flow_start_raw').to_i / 1000); event.set('flow_end_raw', event.get('flow_end_raw').to_i / 1000)"
      }
    } else if [netflow][flow_start_seconds] and [netflow][flow_end_seconds] {
      mutate {
        add_field => {
          "flow_start_raw" => "%{[netflow][flow_start_seconds]}"
          "flow_end_raw" => "%{[netflow][flow_end_seconds]}"
        }
      }
    }

    if [netflow][exporter][address] {
      grok {
        match => [ "[netflow][exporter][address]", "^%{IP:netflow.exporter.ip}" ]
      }
    }

    # this is strictly cosmetic
    mutate {
      remove_tag => [ "process_archive" ]
    }
  }

  if [type] == "netflow" or [type] == "archive-netflow" {
    ## unify timestamp formats between live and archive
    ##  2014-05-11 16:25:11.841 (archived from nfdump)
    date {
      match => [ "flow_start_raw", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601", "UNIX" ]
      target => "[netflow][flow_start]"
    }
    date {
      match => [ "flow_end_raw", "YYYY-MM-dd'THH:mm:ss.SSS'Z", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601", "UNIX" ]
      target => "[netflow][flow_end]"
    }

    mutate {
      # use the flow start timestamp for the event timestamp
      replace => { "@timestamp" => "%{[netflow][flow_start]}" }
      remove_field => [ "flow_start_raw", "flow_end_raw" ]
    }

    if [netflow][flow_duration_microseconds] {
      mutate {
        add_field => { "[netflow][flow_duration]" => "%{[netflow][flow_duration_microseconds]}" }
      }
      ruby {
        code => "event.set('netflow.flow_duration', event.get('netflow.flow_duration').to_i / 1000000)"
      }
    } else if [netflow][flow_duration_milliseconds] {
      mutate {
        add_field => { "[netflow][flow_duration]" => "%{[netflow][flow_duration_milliseconds]}" }
      }
      ruby {
        code => "event.set('netflow.flow_duration', event.get('netflow.flow_duration').to_i / 1000)"
      }
    } else if [netflow][connection_sum_duration_seconds] {
      mutate {
        add_field => { "[netflow][flow_duration]" => "%{[netflow][connection_sum_duration_seconds]}" }
      }
    } else {
      # Calculate the duration from flow_start and flow_end
      ruby {
        init => "require 'date'"
        code => "event.set('netflow.flow_duration', event.get('netflow.flow_end').to_f - event.get('netflow.flow_start').to_f)"
        add_tag => [ "calculated_duration" ]
      }
    }

    # if not TCP, no need for the tcp_flags fields
    if [network][iana_number] != 6 {
      mutate {
        remove_field => [ "netflow.tcp_flags_str", "netflow.tcp_control_bits" ]
      }

    } else if [netflow][tcp_flags_str] {
      # convert integer TCP flag value to an array, flag string, and hex byte
      # convert text TCP flag string to an array and hex byte
      ruby {
        path => "/usr/local/sof-elk/supporting-scripts/tcp_flags_to_array.rb"
        script_params => {
          "source_field" => "[netflow][tcp_flags_str]"
          "source_type" => "str"
        }
      }
    } else if [netflow][tcp_control_bits] {
      ruby {
        path => "/usr/local/sof-elk/supporting-scripts/tcp_flags_to_array.rb"
        script_params => {
          "source_field" => "[netflow][tcp_control_bits]"
          "source_type" => "int"
        }
      }
    }

    # replace the numerical protocol number with a text equivalent
    if [network][iana_number] and ![network][transport] {
      translate {
        dictionary_path => "/usr/local/sof-elk/lib/dictionaries/ip_proto_int2netflow.yaml"
        source => "[network][iana_number]"
        target => "[network][transport]"
      }
    }

    # populate additional fields or modify as needed to match flow sources
    if ![netflow][delta_flow_count] or [netflow][delta_flow_count] == "0" {
      mutate {
        add_field => { "[netflow][delta_flow_count]" => "1" }
      }
    }
    if ![missed_bytes] {
      mutate {
        add_field => { "missed_bytes" => "0" }
      }
    }
    if ![destination][bytes] {
      mutate {
        add_field => { "[destination][bytes]" => "0" }
      }
    }
    if ![destination][packets] {
      mutate {
        add_field => { "[destination][packets]" => "0" }
      }
    }
    if ![source][bytes] {
      mutate {
        add_field => { "[source][bytes]" => "0" }
      }
    }
    if ![source][packets] {
      mutate {
        add_field => { "[source][packets]" => "0" }
      }
    }

    # convert types
    mutate {
      convert => {
        "[destination][bytes]" => "integer"
        "[source][bytes]" => "integer"
        "[netflow][delta_flow_count]" => "integer"
        "[destination][packets]" => "integer"
        "[source][packets]" => "integer"
        "missed_bytes" => "integer"
      }
      add_field => { "path" => "NetFlow from %{[netflow][exporter][ip]}" }
    }
  }

  if [type] == "archive-netflow" {
    if [network][iana_number] == "1" {
      mutate {
        replace => {
          "[source][port]" => "%{icmp_type}"
          "[destination][port]" => "%{icmp_code}"
        }
      }
      mutate {
        remove_field => [ "icmp_type", "icmp_code" ]
      }
    }
  }
}
